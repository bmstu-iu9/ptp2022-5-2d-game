<!DOCTYPE html>
<html>

<head>
  <title>Арканоид</title>
  <div> </div>
  <style>    
    html,
    body {
      height: 100%;
      margin: 0;
    }    
    body {
      background: black;
      display: flex;
      align-items: center;
    }
  </style>
</head>

<body>
    <table align="left" width="715" border="0"
    align="center" cellspacing="0" cellpadding="5">
    <tr bgcolor="black">
        <td height="10">
            <font
                size="8"color="white" face = "">
                Правила игры:
            </font>
        </td>
       </tr>
           <td>
                <p>
                    <font
                        size="4"color="white" face = "">
                        1) Ваша цель - пройти пять уровней, разбив все блоки на каждом из них <br>
                        2) Новый уровень - новый чекпоинт <br>
                        3) Белые, светло-серые и светло-оранжевые блоки увеличивают размер платформы <br>
                        4) Коричневые, тёмно-серые блоки и блоки цвета tomato увеличивают скорость шарика <br>
                        5) Светло-зелёные блоки уменьшают скорость шарика <br>
                        6) Блоки розового цвета дают вам дополнительную жизнь <br>
                        7) Блоки бордового цвета добавляют второй шарик
                    </font>
                </p>
                
            <form>
                <p>
                    <button onclick="play()">Играть</button>
                </p>
            </form>
            <form>
                <p>
                    <button onclick="edit()"> Эдитор уровней</button>
                </p>
            </form>
           </td>
        
           
 <tr bgcolor="black">
   <td colspan="2" width="30%">
  <canvas 
  width="400" height="480" id="game">
  </canvas>
  </td>
 </tr>
</table>
  <script>

    // добавлен выбор кирпичей в эдиторе

    // ОПИСАНИЕ ПЕРЕМЕННЫХ

    var canvas = document.getElementById('game');
    var context = canvas.getContext('2d');
    var curlevel = 0; // уровень, который мы проходим в данный момент ; 0 для эдитора, 1 для нормальной игры
    var extralives = 0; // количество жизней
    var bonusbricks = 0; // количество кирпичей с бонусами для ограничения
    var bottom = 0; // низ уровня для ограничения движения платформы





    // ОПИСАНИЕ УРОВНЕЙ 

    var level1 = [ // первый уровень (радуга)
      [],
      [],
      [],
      [],
      [],
      [],
      ['R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R'],
      ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],
      ['Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y'],
      ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G'],
      ['LG', 'LG', 'LG', 'LG', 'LG', 'LG', 'LG', 'LG', 'LG', 'LG', 'LG', 'LG', 'LG', 'LG'],
      ['B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B'],
      ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P']
    ];

    var level2 = [ // второй уровень (space invaders)
      [],
      [],
      ['E', 'E', 'E', 'Y', 'E', 'E', 'E', 'E', 'E', 'Y', 'E', 'E', 'E'],
      ['E', 'E', 'E', 'Y', 'E', 'E', 'E', 'E', 'E', 'Y', 'E', 'E', 'E'],
      ['E', 'E', 'E', 'E', 'Y', 'E', 'E', 'E', 'Y', 'E', 'E', 'E', 'E'],
      ['E', 'E', 'E', 'E', 'Y', 'E', 'E', 'E', 'Y', 'E', 'E', 'E', 'E'],
      ['E', 'E', 'E', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'E', 'E', 'E'],
      ['E', 'E', 'E', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'E', 'E', 'E'],
      ['E', 'E', 'GR', 'GR', 'R', 'GR', 'GR', 'GR', 'R', 'GR', 'GR', 'E', 'E'],
      ['E', 'E', 'GR', 'GR', 'R', 'GR', 'GR', 'GR', 'R', 'GR', 'GR', 'E', 'E'],
      ['E', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'E'],
      ['E', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'E'],
      ['E', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'E'],
      ['E', 'GR', 'E', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'GR', 'E', 'GR', 'E'],
      ['E', 'GR', 'E', 'GR', 'E', 'E', 'E', 'E', 'E', 'GR', 'E', 'GR', 'E'],
      ['E', 'GR', 'E', 'GR', 'E', 'E', 'E', 'E', 'E', 'GR', 'E', 'GR', 'E'],
      ['E', 'E', 'E', 'E', 'GR', 'GR', 'E', 'GR', 'GR', 'E', 'E', 'E', 'E'],
      ['E', 'E', 'E', 'E', 'GR', 'GR', 'E', 'GR', 'GR', 'E', 'E', 'E', 'E']
    ];

    var level3 = [ // третий уровень (смайлик)
        [],
        [],
        [],
        ['E', 'E', 'E', 'E', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'E', 'E', 'E', 'E'],
        ['E', 'E', 'E', 'E', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'E', 'E', 'E', 'E'],
        ['E', 'E', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'E', 'E'],
        ['E', 'E', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'E', 'E'],
        ['C', 'C', 'C', 'C', 'E', 'E', 'C', 'C', 'C', 'C', 'E', 'E', 'C', 'C', 'C', 'C'],
        ['C', 'C', 'C', 'C', 'E', 'E', 'C', 'C', 'C', 'C', 'E', 'E', 'C', 'C', 'C', 'C'],
        ['C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C'],
        ['C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C'],
        ['C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C'],
        ['C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C'],
        ['C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C'],
        ['C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C'],
        ['C', 'C', 'C', 'C', 'GR', 'GR', 'C', 'C', 'C', 'C', 'GR', 'GR', 'C', 'C', 'C', 'C'],
        ['C', 'C', 'C', 'C', 'GR', 'GR', 'C', 'C', 'C', 'C', 'GR', 'GR', 'C', 'C', 'C', 'C'],
        ['E', 'E', 'C', 'C', 'C', 'C', 'GR', 'GR', 'GR', 'GR', 'C', 'C', 'C', 'C', 'E', 'E'],
        ['E', 'E', 'C', 'C', 'C', 'C', 'GR', 'GR', 'GR', 'GR', 'C', 'C', 'C', 'C', 'E', 'E'],
        ['E', 'E', 'E', 'E', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'E', 'E', 'E', 'E'],
        ['E', 'E', 'E', 'E', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'E', 'E', 'E', 'E']
    ];

    var level4 = [ // четвёртый уровень (зонтик)

    [],
    [],
    ['E', 'E', 'E', 'E', 'E', 'E', 'GR', 'E', 'E', 'E', 'E', 'E', 'E'],
    ['E', 'E', 'E', 'B', 'B', 'B', 'GR', 'G', 'G', 'G', 'E', 'E', 'E'],
    ['E', 'E', 'B', 'B', 'B', 'R', 'R', 'R', 'G', 'G', 'G', 'E', 'E'],
    ['E', 'E', 'B', 'B', 'R', 'R', 'R', 'R', 'R', 'G', 'G', 'E', 'E'],
    ['E', 'B', 'B', 'B', 'R', 'R', 'R', 'R', 'R', 'G', 'G', 'G', 'E'],
    ['E', 'B', 'B', 'B', 'R', 'R', 'R', 'R', 'R', 'G', 'G', 'G', 'E'],
    ['E', 'B', 'B', 'B', 'R', 'R', 'R', 'R', 'R', 'G', 'G', 'G', 'E'],
    ['E', 'GR', 'E', 'E', 'GR', 'E', 'GR', 'E', 'GR', 'E', 'E', 'GR', 'E'],
    ['E', 'E', 'E', 'E', 'E', 'E', 'GR', 'E', 'E', 'E', 'E', 'E', 'E'],
    ['E', 'E', 'E', 'E', 'E', 'E', 'GR', 'E', 'E', 'E', 'E', 'E', 'E'],
    ['E', 'E', 'E', 'E', 'E', 'E', 'GR', 'E', 'E', 'E', 'E', 'E', 'E'],
    ['E', 'E', 'E', 'E', 'Y', 'E', 'Y', 'E', 'E', 'E', 'E', 'E', 'E'],
    ['E', 'E', 'E', 'E', 'Y', 'Y', 'Y', 'E', 'E', 'E', 'E', 'E', 'E'],
    ['E', 'E', 'E', 'E', 'E', 'Y', 'E', 'E', 'E', 'E', 'E', 'E', 'E']
    ];

    var level5 = [ // пятый уровень (сердце)

    [],
    [],
    [],
    [],
    ['E', 'E', 'E', 'R', 'R', 'E', 'E', 'E', 'R', 'R', 'E', 'E', 'E'],
    ['E', 'E', 'R', 'R', 'R', 'R', 'E', 'R', 'R', 'R', 'R', 'E', 'E'],
    ['E', 'E', 'R', 'R', 'R', 'R', 'E', 'R', 'R', 'R', 'R', 'E', 'E'],
    ['E', 'R', 'R', 'R', 'R', 'GR', 'GR', 'R', 'R', 'R', 'R', 'R', 'E'],
    ['E', 'R', 'R', 'R', 'R', 'GR', 'GR', 'R', 'R', 'R', 'R', 'R', 'E'],
    ['E', 'R', 'R', 'R', 'R', 'R', 'GR', 'GR', 'R', 'R', 'R', 'R', 'E'],
    ['E', 'R', 'R', 'R', 'R', 'R', 'GR', 'GR', 'R', 'R', 'R', 'R', 'E'],
    ['E', 'E', 'R', 'R', 'R', 'GR', 'GR', 'R', 'R', 'R', 'R', 'E', 'E'],
    ['E', 'E', 'R', 'R', 'R', 'GR', 'GR', 'R', 'R', 'R', 'R', 'E', 'E'],
    ['E', 'E', 'E', 'R', 'R', 'R', 'GR', 'GR', 'R', 'R', 'E', 'E', 'E'],
    ['E', 'E', 'E', 'R', 'R', 'R', 'GR', 'GR', 'R', 'R', 'E', 'E', 'E'],
    ['E', 'E', 'E', 'E', 'R', 'GR', 'GR', 'R', 'R', 'E', 'E', 'E', 'E'],
    ['E', 'E', 'E', 'E', 'E', 'GR', 'GR', 'R', 'E', 'E', 'E', 'E', 'E'],
    ['E', 'E', 'E', 'E', 'E', 'E', 'GR', 'E', 'E', 'E', 'E', 'E', 'E']
    ];

    // для создания кирпичей по массивам выше
    const colorMap = {
      'C': 'coral',
      'R': 'red',
      'O': 'orange',
      'G': 'green',
      'Y': 'yellow',
      'GR': 'gray',
      'LG': 'dodgerblue',
      'B': 'blue',
      'P': 'purple'
    };





    // ОПИСАНИЕ ХАРАКТЕРИСТИК КИРПИЧЕЙ И СТЕН

    const brickGap = 2; // пространство между двумя соседними кирпичами
    var brickWidth = 25; // длина кирпича
    const brickHeight = 12; // высота кирпича
    var wallSize = 12; // толщина стен
    var twoballs = false; // false => один шарик, true => два

    // платформа
    var paddle = {
      x: canvas.width / 2 - brickWidth,
      y: 440,
      width: 50,
      height: brickHeight,
      dx: 0,
      dy: 0
    };

    // шарик
    var ball = {
      x: paddle.x + paddle.width / 2,
      y: paddle.y + paddle.height,
      width: 5,
      height: 5,
      speed: 3,
      dx: 0,
      dy: 0
    };

    // второй шарик
    var secondball ={
      x: paddle.x + paddle.width / 2,
      y: paddle.y + paddle.height,
      width: 5,
      height: 5,
      speed: 3,
      dx: 0,
      dy: 0
    };

    var bricks = []; // массив кирпичей

    // строим первый уровень
    if (curlevel == 1) {
    for (let row = 0; row < level1.length; row++) {
      for (let col = 0; col < level1[row].length; col++) {

        let rand = getRandomInt(50); // переменная для определения бонусных кирпичей
        if (bonusbricks < 5) { // ограничиваем количество бонусных кирпичей
        if (rand == 7) {
            bonusbricks += 1;
            bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'white',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 19) { // увеличение скорости
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'saddlebrown',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 0) { // дополнительная жизнь
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'magenta',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 21) { // уменьшение скорости
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'lime',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 42) { // второй шарик
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'maroon',
          width: brickWidth,
          height: brickHeight
        });
    } else { // обычный блок
        const colorCode = level1[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });
    }
} else { // обычный блок
        const colorCode = level1[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });
        }
    }
    }
}



    // функция для определения случайного числа для распределения бонусных блоков
    function getRandomInt(max) {
      return Math.floor(Math.random() * max);
    }



    // проверка двух объектов на колллизию
    function collides(obj1, obj2) {
      return obj1.x < obj2.x + obj2.width &&
        obj1.x + obj1.width > obj2.x &&
        obj1.y < obj2.y + obj2.height &&
        obj1.y + obj1.height > obj2.y;
    }



    // отслеживаем нажатия игрока на клавиши
    document.addEventListener('keydown', function(e) {

      // стрелка влево
      if (e.which === 37) { 
        paddle.dx = -3;
      }
      // стрелка вправо
      if (e.which === 39) {
        paddle.dx = 3;
      }
      // стрелка вверх
      if (e.which === 38) {
        paddle.dy = -3;
      }
      // стрелка вниз
      if (e.which === 40) {
        paddle.dy = 3;
      }

      // если шарик не запущен — запускаем его на пробел или enter
      if (ball.dx === 0 && ball.dy === 0 && (e.which === 32 || e.which === 13)) {
        ball.x = paddle.x + paddle.width / 2;
        ball.dx = paddle.dx;
        ball.dy = -ball.speed;
      }

      // если второй шарик существует и не запущен — запускаем его на пробел или enter
      if (twoballs == true && secondball.dx === 0 && secondball.dy === 0 && (e.which === 32 || e.which === 13)) {
        secondball.x = paddle.x + paddle.width / 2;
        secondball.dx = paddle.dx;
        secondball.dy = -secondball.speed;
      }
    });

    // останавливаем платформу, если клавиши не нажаты
    document.addEventListener('keyup', function(e) {
      if (e.which === 37 || e.which === 39) {
        paddle.dx = 0;
      }
      if (e.which === 38 || e.which === 40) {
        paddle.dy = 0;
      }
    });

    // запускаем игру
    if (curlevel == 0) {
        cancelAnimationFrame(game);
        requestAnimationFrame(editor);
    } else {
        cancelAnimationFrame(editor);
        requestAnimationFrame(game);
    }










// САМА ИГРА

function game() {
      requestAnimationFrame(game);



      // переходим на следующий уровень, если этот зачищен
      if (bricks.length == 0) { 

        // убираем второй шарик
        twoballs = false;
        secondball.x = paddle.x + paddle.width / 2;
        secondball.y = paddle.y + paddle.height;
        secondball.dx = 0;
        secondball.dy = 0;

        // обнуляем статы для нового уровня
        bonusbricks = 0;
        extralives = 0;

        if (curlevel == 1) { // переход на второй уровень

          // подгоняем характеристики для второго уровня
          curlevel = 2;
          brickWidth = 24;
          wallSize = 32;

          // строим второй уровень
          for (let row = 0; row < level2.length; row++) {
            for (let col = 0; col < level2[row].length; col++) {

              if (level2[row][col] != 'E') {
                    let rand = getRandomInt(50); // переменная для определения бонусных кирпичей
                if (bonusbricks < 5) { // ограничение количества бонусных кирпичей
        if (rand == 7) { // увеличение платформы
            bonusbricks += 1;
            bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'silver',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 19) { // увеличение скорости шарика
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'dimgrey',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 0) { // дополнительная жизнь
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'magenta',
          width: brickWidth,
          height: brickHeight
        }); 
    } else if (rand == 21) { // уменьшение скорости шарика
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'lime',
          width: brickWidth,
          height: brickHeight
        }); 
    } else if (rand == 42) { // второй шарик
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'maroon',
          width: brickWidth,
          height: brickHeight
        });
    } else { // обычный блок
        const colorCode = level2[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });
        }
    } else { // обычный блок
        const colorCode = level2[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });
    }
              }
            }
          }
            
        } else if (curlevel == 2) { // переход на третий

          // подгоянем статы для третьего уровня
          curlevel = 3;
          brickWidth = 20;
          wallSize = 25;

            for (let row = 0; row < level3.length; row++) {
            for (let col = 0; col < level3[row].length; col++) {
              if (level3[row][col] != 'E') {
                let rand = getRandomInt(50); // переменная для определения бонусных кирпичей
                if (bonusbricks < 5) { // ограничение количества бонусных кирпичей
        if (rand == 7) { // увеличение платформы
            bonusbricks += 1;
            bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'lightsalmon',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 19) { // увеличение скорости шарика
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'tomato',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 0) { // дополнительная жизнь
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'magenta',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 21) { // уменьшение скорости шарика
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'lime',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 42) { // второй шарик
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'maroon',
          width: brickWidth,
          height: brickHeight
        });
    } else { // обычный блок
        const colorCode = level3[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });
        }
    } else { // обычный блок
        const colorCode = level3[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });
    }
              }
            }
          }
        
        } else if (curlevel == 3) { // переход на четвертый

          // подгоняем статы для четвертого уровня
          curlevel = 4;
          brickWidth = 24;
          wallSize = 32;

            for (let row = 0; row < level4.length; row++) {
            for (let col = 0; col < level4[row].length; col++) {
              if (level4[row][col] != 'E') {
                let rand = getRandomInt(50); // переменная для распределения бонусных блоков
                if (bonusbricks < 5) { // ограничение количества бонусных блоков
        if (rand == 7) { // увеличение платформы
            bonusbricks += 1;
            bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'white',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 19) { // увеличение скорости шарика
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'saddlebrown',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 0) { // дополнительная жизнь
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'magenta',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 21) { // уменьшение скорости шарика
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'lime',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 42) { // второй шарик
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'maroon',
          width: brickWidth,
          height: brickHeight
        });
    } else { // обычный блок
        const colorCode = level4[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });
        }
    } else { // обычный блок 
        const colorCode = level4[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });  
    }
              }
            }
          }
          
        } else if (curlevel = 4) {  // переход на пятый уровень

          // подгоняем статы для пятого уровня
          curlevel = 5;
          brickWidth = 24;
          wallSize = 32;

            for (let row = 0; row < level5.length; row++) {
            for (let col = 0; col < level5[row].length; col++) {
              if (level5[row][col] != 'E') {
                let rand = getRandomInt(50); // переменная для распределения бонусных блоков
                if (bonusbricks < 5) { // ограничение количества бонусных блоков
        if (rand == 7) { // увеличение платформы
            bonusbricks += 1;
            bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'white',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 19) { // увеличение скорости шарика
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'saddlebrown',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 0) { // дополнительная жизнь
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'magenta',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 21) { // уменьшение скорости шарика
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'lime',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 42) { // второй шарик
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'maroon',
          width: brickWidth,
          height: brickHeight
        });
    } else { // обычный блок
        const colorCode = level5[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });
        }
    } else { // обычный блок
        const colorCode = level5[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });  
    }
              }
            }
          }
        }
        // телепортируем платформу в центр
        paddle.x = canvas.width / 2 - brickWidth;
          paddle.y = 440;
      
          // телепортируем шарик к платформе
          ball.dx = 0;
          ball.dy = 0;
      }

      // на каждом кадре всё стираем 
      context.clearRect(0, 0, canvas.width, canvas.height);

    



      // начинаем заново уровень, если жизней ноль, иначе телепортируем его к платформе
      if (ball.y > paddle.y + 75) {

        if (extralives == 0) {

          // убираем второй шарик и обнуляем количество бонусных кирпичей
          twoballs = false;
          secondball.dx = 0;
          secondball.dy = 0;
          bonusbricks = 0;

        if (curlevel == 1) { // рестарт первого уровня (строим его как и раньше)
       
        // обнуляем массив кирпичей
        bricks = [];

        for (let row = 0; row < level1.length; row++) {
          for (let col = 0; col < level1[row].length; col++) {

            if (level1[row][col] != 'E') {
            let rand = getRandomInt(50);
            if (bonusbricks < 5) {
        if (rand == 7) {
            bonusbricks += 1;
            bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'white',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 19) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'saddlebrown',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 0) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'magenta',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 21) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'lime',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 42) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'maroon',
          width: brickWidth,
          height: brickHeight
        });
    } else {
        const colorCode = level1[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });
        }
    } else {
        const colorCode = level1[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });
    }
    }
          }
        }
      }

      if (curlevel == 2) { // рестарт второго уровня (строим его как и раньше)
        
        // обнуляем массив кирпичей
        bricks = [];

        for (let row = 0; row < level2.length; row++) {
            for (let col = 0; col < level2[row].length; col++) {

                if (level2[row][col] != 'E') {
                    let rand = getRandomInt(50);
                    if (bonusbricks < 5) {
                    if (rand == 7) {
                        bonusbricks += 1;
            bricks.push({
                x: wallSize + (brickWidth + brickGap) * col,
                y: wallSize + (brickHeight + brickGap) * row,
                color: 'silver',
                width: brickWidth,
                height: brickHeight
        });
    } else if (rand == 19) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'dimgrey',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 0) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'magenta',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 21) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'lime',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 42) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'maroon',
          width: brickWidth,
          height: brickHeight
        });
    } else {
        const colorCode = level2[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });
        }
    } else {
        const colorCode = level2[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });
    }
              }
            }
          }
      }

      if (curlevel == 3) { // рестарт третьего уровня (строим его как и раньше)
       
        // обнуляем массив кирпичей
        bricks = [];

        for (let row = 0; row < level3.length; row++) {
            for (let col = 0; col < level3[row].length; col++) {

                if (level3[row][col] != 'E') {
                let rand = getRandomInt(50);
                if (bonusbricks < 5) {
        if (rand == 7) {
            bonusbricks += 1;
            bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'lightsalmon',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 19) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'tomato',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 0) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'magenta',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 21) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'lime',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 42) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'maroon',
          width: brickWidth,
          height: brickHeight
        });
    } else {
        const colorCode = level3[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });
        }
    } else {
        const colorCode = level3[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });
    }
              }
            }
          }
      }

      if (curlevel == 4) { // рестарт четвертого уровня (строим его как и раньше)

            // подгоняем статы для четвертого уровня
            brickWidth = 20;
            wallSize = 25;

            // обнуляем массив кирпичей
            bricks = [];

            for (let row = 0; row < level4.length; row++) {
            for (let col = 0; col < level4[row].length; col++) {

              if (level4[row][col] != 'E') {
                let rand = getRandomInt(50);
                if (bonusbricks < 5) {
        if (rand == 7) {
            bonusbricks += 1;
            bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'white',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 19) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'saddlebrown',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 0) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'magenta',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 21) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'lime',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 42) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'maroon',
          width: brickWidth,
          height: brickHeight
        });
    } else {
        const colorCode = level4[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });
        }
    } else {
        const colorCode = level4[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });
    }
              }
            }
          }
      }
      if (curlevel == 5) { // рестарт пятого уровня (строим его как и раньше)

        // обнуляем массив кирпичей
        bricks = [];

        for (let row = 0; row < level5.length; row++) {
            for (let col = 0; col < level5[row].length; col++) {

              if (level5[row][col] != 'E') {
                let rand = getRandomInt(50);
                if (bonusbricks < 5) {
        if (rand == 7) {
            bonusbricks += 1;
            bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'white',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 19) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'saddlebrown',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 0) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'magenta',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 21) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'lime',
          width: brickWidth,
          height: brickHeight
        });
    } else if (rand == 42) {
        bonusbricks += 1;
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: 'maroon',
          width: brickWidth,
          height: brickHeight
        });
    } else {
        const colorCode = level5[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });
        }
    } else {
        const colorCode = level5[row][col];
        bricks.push({
          x: wallSize + (brickWidth + brickGap) * col,
          y: wallSize + (brickHeight + brickGap) * row,
          color: colorMap[colorCode],
          width: brickWidth,
          height: brickHeight
        });  
    }
              }
            }
          }
      }

      // телепортируем платформу в центр
      paddle.x = canvas.width / 2 - brickWidth;
      paddle.y = 440;
    } else {
        extralives -= 1;
    }

    // телепортируем шарик к платформе
    ball.dx = 0;
      ball.dy = 0;
}


   
      // рисуем стены
      context.fillStyle = 'lightgrey';
      context.fillRect(0, 0, canvas.width, wallSize);
      context.fillRect(0, 0, wallSize, canvas.height);
      context.fillRect(canvas.width - wallSize, 0, wallSize, canvas.height);

      // рисуем кирпичи
      bricks.forEach(function(brick) {
        context.fillStyle = brick.color;
        context.fillRect(brick.x, brick.y, brick.width, brick.height);
      });




      // РАБОТА С ШАРИКОМ

      // лепим шарик к платформе, если его скорость равна нулю
      context.fillStyle = 'white';
      if (ball.dx == 0 && ball.dy == 0) {
        ball.x = paddle.x + paddle.width / 2 - ball.width / 2;
        ball.y = paddle.y - paddle.height / 2;
      }

      // рисуем шарик
    var circle = new Path2D();
    circle.arc(ball.x + ball.width / 2, ball.y + ball.height / 2, ball.width * 0.5, 0, 2 * Math.PI);
    context.fill(circle);

    // двигаем шарик
    ball.x += ball.dx;
      ball.y += ball.dy;

      // ограничиваем скорость шарика по оси игрек
      if (ball.dy > 4.25) {
        ball.dy = 4.25;
      }
      if (ball.dy < -4.25) {
        ball.dy = -4.25;
      }

      // проверяем каждый кирпич на касание его шариком
      bottom = 0;
      for (let i = 0; i < bricks.length; i++) {
        const brick = bricks[i];

        // параллельно находим самый низ уровня
        if (brick.y > bottom) {
            bottom = brick.y;
        }
        if (collides(ball, brick)) {
        if (brick.color == 'white' || brick.color == 'silver' || brick.color == 'lightsalmon') // увеличение размера платформы
        {
            if (paddle.width < 100) {
            paddle.width *= 1.5;
            }
        } else if (brick.color == 'saddlebrown' || brick.color == 'dimgrey' || brick.color == 'tomato') { // увеличение скорости шарика
            ball.dx *= 1.3;
            ball.dy *= 1.3;
        } else if (brick.color == 'magenta') { // дополнительная жизнь
            extralives += 1;
        } else if (brick.color == 'lime') { // замедление шарика
            ball.dx /= 1.3;
            ball.dy /= 1.3;
        } else if (brick.color == 'maroon') { // второй шарик
            twoballs = true;
            secondball.y = paddle.y - paddle.height / 2;
        }
          // убираем кирпич из массива
          bricks.splice(i, 1);
          // если шарик коснулся кирпича сверху или снизу — меняем направление движения шарика по оси игрек
          if (ball.y + ball.height - ball.speed <= brick.y ||
            ball.y >= brick.y + brick.height - ball.speed) {
            ball.dy *= -1;
          }
          // в противном случае меняем направление движения шарика по оси икс
          else {
            ball.dx *= -1;
          }
          // как нашли касание — сразу выходим из цикла проверки
          break;
        }
      }

      // проверка шарика на коллизию с боковыми стенками
      if (ball.x < wallSize) {
        ball.x = wallSize;
        ball.dx *= -1;
      } else if (ball.x + ball.width > canvas.width - wallSize) {
        ball.x = canvas.width - wallSize - ball.width;
        ball.dx *= -1;
      }

      // проверка шарика на коллизию с верхней стенкой
      if (ball.y < wallSize) {
        ball.y = wallSize;
        ball.dy *= -1;
      }





    // РАБОТА СО ВТОРЫМ ШАРИКОМ  

    // лепим второй шарик к платформе, если его скорость равна нулю и он вообще существует
    if (twoballs == true) {
      if (secondball.dx == 0 && secondball.dy == 0) {
        secondball.x = paddle.x + paddle.width / 2 - secondball.width / 2;
        secondball.y = paddle.y - paddle.height / 2;
      }

      // рисуем второй шарик
      context.fillStyle = 'red';
      var secondcircle = new Path2D();
    secondcircle.arc(secondball.x + secondball.width / 2, secondball.y + secondball.height / 2, secondball.width * 0.5, 0, 2 * Math.PI);
    context.fill(secondcircle);
    }

    // двигаем второй шарик, если он существует
    if (twoballs == true) {
        secondball.x += secondball.dx;
        secondball.y += secondball.dy;
      }

      // ограничиваем скорость второго шарика по оси игрек
      if (secondball.dy > 4.25) {
        secondball.dy = 4.25;
      }
      if (secondball.dy < -4.25) {
        secondball.dy = -4.25;
      }

      // аналогичная проверка коллизии с кирпичами для второго шарика в случае его существования
      if (twoballs == true) {
      for (let i = 0; i < bricks.length; i++) {
        const brick = bricks[i];
        if (collides(secondball, brick)) {
        if (brick.color == 'white' || brick.color == 'silver' || brick.color == 'lightsalmon') 
        {
            if (paddle.width < 100) {
            paddle.width *= 1.5;
            }
        } else if (brick.color == 'saddlebrown' || brick.color == 'dimgrey' || brick.color == 'tomato') {
            secondball.dx *= 1.3;
            secondball.dy *= 1.3;
        } else if (brick.color == 'magenta') { 
            extralives += 1;
        } else if (brick.color == 'lime') {
            secondball.dx /= 1.3;
            secondball.dy /= 1.3;
        }
          bricks.splice(i, 1);
          if (secondball.y + secondball.height - secondball.speed <= brick.y ||
            secondball.y >= brick.y + brick.height - secondball.speed) {
            secondball.dy *= -1;
          }
          else {
            secondball.dx *= -1;
          }
          break;
        }
      }
    }

    // проверка второго шарика на коллизию с боковыми стенками,если он существует 
    if (twoballs == true && secondball.x < wallSize) {
        secondball.x = wallSize;
        secondball.dx *= -1;
      } else if (twoballs == true && secondball.x + secondball.width > canvas.width - wallSize) {
        secondball.x = canvas.width - wallSize - secondball.width;
        secondball.dx *= -1;
      }

      // проверка второго шарика на коллизиюс верхней стенкой, если он существует
      if (twoballs == true && secondball.y < wallSize) {
        secondball.y = wallSize;
        secondball.dy *= -1;
      }

      // удаляем второй шарик, если он улетел ниже платформы
      if (secondball.y > paddle.y + 75) {
        twoballs = false;
        secondball.dx = 0;
        secondball.dy = 0;
      }


    


    // РАБОТА С ПЛАТФОРМОЙ

     // рисуем платформу
     context.fillStyle = 'cyan';
      context.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

      // двигаем платформу с нужной скоростью 
      paddle.x += paddle.dx;
      paddle.y += paddle.dy;

      // ограничиваем размер платформы
      if (paddle.width > 100) {
        paddle.width = 100;
      }

      // смотрим, что платформа не уезжает за боковые стенки
      if (paddle.x < wallSize) {
        paddle.x = wallSize
      } else if (paddle.x + paddle.width > canvas.width - wallSize) {
        paddle.x = canvas.width - wallSize - paddle.width;
      }

      // смотрим, что платформа не уезжает выше нижнего кирпича
      if (paddle.y < bottom + 2 * paddle.height) {
        paddle.y = bottom + 2 * paddle.height
      } else if (paddle.y > 450) {
        paddle.y = 450;
      }

      // проверка коллизии шарика с платформой
      if (collides(ball, paddle)) {
        if (ball.x < paddle.x || ball.x + ball.width > paddle.x + paddle.width) { // касание сбоку
            ball.dx *= -1;
            ball.dx += paddle.dx / 2;
            ball.x += ball.dx;
            ball.y += ball.dy;
          } else { // касание сверху
            ball.dx += paddle.dx / 2;
        ball.dy *= -1;
        ball.dy += paddle.dy;
        // сдвигаем шарик выше платформы, чтобы на следующем кадре это снова не засчиталось за столкновение
        ball.y = paddle.y - ball.height;
          }
      }

      // проверка коллизии второго шарика с платформой в случае его существования
      if (twoballs == true && collides(secondball, paddle)) {
        if (secondball.x < paddle.x || secondball.x + secondball.width > paddle.x + paddle.width) {
            secondball.dx *= -1;
            secondball.dx += secondball.dx / 2;
            secondball.x += ball.dx;
            secondball.y += secondball.dy;
          } else {
            secondball.dx += paddle.dx / 2;
            secondball.dy *= -1;
            secondball.dy += paddle.dy;
        secondball.y = paddle.y - secondball.height;
          }
      }
    }










    // ЭДИТОР УРОВНЕЙ

    function editor() {
      requestAnimationFrame(editor);

      // стираем всё на новом кадре
      context.clearRect(0, 0, canvas.width, canvas.height);

      wallSize = 10;
      brickWidth = 25;

      // рисуем стены
      context.fillStyle = 'lightgrey';
      context.fillRect(0, 0, canvas.width, wallSize);
      context.fillRect(0, 0, wallSize, canvas.height);
      context.fillRect(canvas.width - wallSize, 0, wallSize, canvas.height);

      // рисуем кирпичи
      bricks.forEach(function(brick) {
        context.fillStyle = brick.color;
        context.fillRect(brick.x, brick.y, brick.width, brick.height);
      });

      // рисуем кирпичи для выбора 
      context.fillStyle = 'saddlebrown';
      context.fillRect(42, 0, 26, 10);

      context.fillStyle = 'maroon';
      context.fillRect(100, 0, 26, 10);

      context.fillStyle = 'red';
      context.fillRect(158, 0, 26, 10);

      context.fillStyle = 'magenta';
      context.fillRect(216, 0, 26, 10);

      context.fillStyle = 'lime';
      context.fillRect(274, 0, 26, 10);

      context.fillStyle = 'white';
      context.fillRect(332, 0, 26, 10);





      // РАБОТА С ШАРИКОМ

      // лепим шарик к платформе, если его скорость равна нулю
      context.fillStyle = 'white';
      if (ball.dx == 0 && ball.dy == 0) {
        ball.x = paddle.x + paddle.width / 2 - ball.width / 2;
        ball.y = paddle.y - paddle.height / 2;
      }

      // рисуем шарик
    var circle = new Path2D();
    circle.arc(ball.x + ball.width / 2, ball.y + ball.height / 2, ball.width * 0.5, 0, 2 * Math.PI);
    context.fill(circle);

    // двигаем шарик
    ball.x += ball.dx;
      ball.y += ball.dy;

      // ограничиваем скорость шарика по оси игрек
      if (ball.dy > 4.25) {
        ball.dy = 4.25;
      }
      if (ball.dy < -4.25) {
        ball.dy = -4.25;
      }

      // проверяем каждый кирпич на касание его шариком
      bottom = 0;
      for (let i = 0; i < bricks.length; i++) {
        const brick = bricks[i];

        // параллельно находим самый низ уровня
        if (brick.y > bottom) {
            bottom = brick.y;
        }
        if (collides(ball, brick)) {
        if (brick.color == 'white') // увеличение размера платформы
        {
            if (paddle.width < 100) {
            paddle.width *= 1.5;
            }
        } else if (brick.color == 'saddlebrown') { // увеличение скорости шарика
            ball.dx *= 1.3;
            ball.dy *= 1.3;
        } else if (brick.color == 'magenta') { // дополнительная жизнь
            extralives += 1;
        } else if (brick.color == 'lime') { // замедление шарика
            ball.dx /= 1.3;
            ball.dy /= 1.3;
        } else if (brick.color == 'maroon') { // второй шарик
            twoballs = true;
            secondball.y = paddle.y - paddle.height / 2;
        }
          // убираем кирпич из массива
          bricks.splice(i, 1);
          // если шарик коснулся кирпича сверху или снизу — меняем направление движения шарика по оси игрек
          if (ball.y + ball.height - ball.speed <= brick.y ||
            ball.y >= brick.y + brick.height - ball.speed) {
            ball.dy *= -1;
          }
          // в противном случае меняем направление движения шарика по оси икс
          else {
            ball.dx *= -1;
          }
          // как нашли касание — сразу выходим из цикла проверки
          break;
        }
      }

      // проверка шарика на коллизию с боковыми стенками
      if (ball.x < wallSize) {
        ball.x = wallSize;
        ball.dx *= -1;
      } else if (ball.x + ball.width > canvas.width - wallSize) {
        ball.x = canvas.width - wallSize - ball.width;
        ball.dx *= -1;
      }

      // проверка шарика на коллизию с верхней стенкой
      if (ball.y < wallSize) {
        ball.y = wallSize;
        ball.dy *= -1;
      }

      // шарик улетел ниже платформы: рестартим эдитор, если жизней нет, иначе телепортируем шарик к платформе
      if (ball.y > paddle.y + 75) {
        twoballs = false;
        secondball.dx = 0;
        secondball.dy = 0;
        if (extralives > 0) {
            extralives -= 1;
        } else {
            bricks = [];
            paddle.x = canvas.width / 2 - brickWidth;
            paddle.y  = 440;
        }
        ball.dx = 0;
        ball.dy = 0;
      }





    // РАБОТА СО ВТОРЫМ ШАРИКОМ  

    // лепим второй шарик к платформе, если его скорость равна нулю и он вообще существует
    if (twoballs == true) {
      if (secondball.dx == 0 && secondball.dy == 0) {
        secondball.x = paddle.x + paddle.width / 2 - secondball.width / 2;
        secondball.y = paddle.y - paddle.height / 2;
      }

      // рисуем второй шарик
      context.fillStyle = 'red';
      var secondcircle = new Path2D();
    secondcircle.arc(secondball.x + secondball.width / 2, secondball.y + secondball.height / 2, secondball.width * 0.5, 0, 2 * Math.PI);
    context.fill(secondcircle);
    }

    // двигаем второй шарик, если он существует
    if (twoballs == true) {
        secondball.x += secondball.dx;
        secondball.y += secondball.dy;
      }

      // ограничиваем скорость второго шарика по оси игрек
      if (secondball.dy > 4.25) {
        secondball.dy = 4.25;
      }
      if (secondball.dy < -4.25) {
        secondball.dy = -4.25;
      }

      // аналогичная проверка коллизии с кирпичами для второго шарика в случае его существования
      if (twoballs == true) {
      for (let i = 0; i < bricks.length; i++) {
        const brick = bricks[i];
        if (collides(secondball, brick)) {
        if (brick.color == 'white') 
        {
            if (paddle.width < 100) {
            paddle.width *= 1.5;
            }
        } else if (brick.color == 'saddlebrown') {
            secondball.dx *= 1.3;
            secondball.dy *= 1.3;
        } else if (brick.color == 'magenta') { 
            extralives += 1;
        } else if (brick.color == 'lime') {
            secondball.dx /= 1.3;
            secondball.dy /= 1.3;
        }
          bricks.splice(i, 1);
          if (secondball.y + secondball.height - secondball.speed <= brick.y ||
            secondball.y >= brick.y + brick.height - secondball.speed) {
            secondball.dy *= -1;
          }
          else {
            secondball.dx *= -1;
          }
          break;
        }
      }
    }

    // проверка второго шарика на коллизию с боковыми стенками,если он существует 
    if (twoballs == true && secondball.x < wallSize) {
        secondball.x = wallSize;
        secondball.dx *= -1;
      } else if (twoballs == true && secondball.x + secondball.width > canvas.width - wallSize) {
        secondball.x = canvas.width - wallSize - secondball.width;
        secondball.dx *= -1;
      }

      // проверка второго шарика на коллизиюс верхней стенкой, если он существует
      if (twoballs == true && secondball.y < wallSize) {
        secondball.y = wallSize;
        secondball.dy *= -1;
      }

      // удаляем второй шарик, если он улетел ниже платформы
      if (secondball.y > paddle.y + 75) {
        twoballs = false;
        secondball.dx = 0;
        secondball.dy = 0;
      }


    


    // РАБОТА С ПЛАТФОРМОЙ

     // рисуем платформу
     context.fillStyle = 'cyan';
      context.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

      // двигаем платформу с нужной скоростью 
      paddle.x += paddle.dx;
      paddle.y += paddle.dy;

      // ограничиваем размер платформы
      if (paddle.width > 100) {
        paddle.width = 100;
      }

      // смотрим, что платформа не уезжает за боковые стенки
      if (paddle.x < wallSize) {
        paddle.x = wallSize
      } else if (paddle.x + paddle.width > canvas.width - wallSize) {
        paddle.x = canvas.width - wallSize - paddle.width;
      }

      // смотрим, что платформа не уезжает выше нижнего кирпича
      if (paddle.y < bottom + 2 * paddle.height) {
        paddle.y = bottom + 2 * paddle.height
      } else if (paddle.y > 450) {
        paddle.y = 450;
      }

      // проверка коллизии шарика с платформой
      if (collides(ball, paddle)) {
        if (ball.x < paddle.x || ball.x + ball.width > paddle.x + paddle.width) { // касание сбоку
            ball.dx *= -1;
            ball.dx += paddle.dx / 2;
            ball.x += ball.dx;
            ball.y += ball.dy;
          } else { // касание сверху
            ball.dx += paddle.dx / 2;
        ball.dy *= -1;
        ball.dy += paddle.dy;
        // сдвигаем шарик выше платформы, чтобы на следующем кадре это снова не засчиталось за столкновение
        ball.y = paddle.y - ball.height;
          }
      }

      // проверка коллизии второго шарика с платформой в случае его существования
      if (twoballs == true && collides(secondball, paddle)) {
        if (secondball.x < paddle.x || secondball.x + secondball.width > paddle.x + paddle.width) {
            secondball.dx *= -1;
            secondball.dx += secondball.dx / 2;
            secondball.x += ball.dx;
            secondball.y += secondball.dy;
          } else {
            secondball.dx += paddle.dx / 2;
            secondball.dy *= -1;
            secondball.dy += paddle.dy;
        secondball.y = paddle.y - secondball.height;
          }
      }
    }










// РАБОТАЕМ С ВЫБОРОМ И УСТАНОВКОЙ КИРПИЧЕЙ    

canvas.addEventListener('click', handlerClickCanvas);
let clientX = 0;
let clientY = 0;

    function handlerClickCanvas(e) {

      // делаем так, чтоб нажатие нормально читалось
  clientX = e.clientX - 5;
  clientY = e.clientY - 333;

  let x = clientX;
  let y = clientY;

  // ставим координаты, подходящие к сетке потенциальных кирпичей
  clientX = brickGap + wallSize + (clientX - wallSize) - ((clientX - wallSize) % 27);
  clientY = brickGap + wallSize + (clientY - wallSize) - ((clientY - wallSize) % 14);

  if (curlevel == 0 && clientY < 410 && clientX < 390) {
    if (y <= 10 && x >= 42 && x <= 68) { // выбрали коричневый цвет
        bricks.push({
          x: clientX,
          y: clientY,
          color: 'black',
          futurecolor: 'saddlebrown',
          width: brickWidth,
          height: brickHeight
        });
    } else if (y <= 10 && x >= 100 && x <= 126) { // выбрали тёмно-красный цвет
        bricks.push({
          x: clientX,
          y: clientY,
          color: 'black',
          futurecolor: 'maroon',
          width: brickWidth,
          height: brickHeight
        });
    } else if (y <= 10 && x >= 158 && x <= 184) { // выбрали красный цвет
        bricks.push({
          x: clientX,
          y: clientY,
          color: 'black',
          futurecolor: 'red',
          width: brickWidth,
          height: brickHeight
        });
    } else if (y <= 10 && x >= 216 && x <= 242) { // выбрали розовый цвет
        bricks.push({
          x: clientX,
          y: clientY,
          color: 'black',
          futurecolor: 'magenta',
          width: brickWidth,
          height: brickHeight
        });
    } else if (y <= 10 && x >= 274 && x <= 300) { // выбрали светло-зелёный цвет
        bricks.push({
          x: clientX,
          y: clientY,
          color: 'black',
          futurecolor: 'lime',
          width: brickWidth,
          height: brickHeight
        });
    } else if (y <= 10 && x >= 332 && x <= 358) { // выбрали белый цвет
        bricks.push({
          x: clientX,
          y: clientY,
          color: 'black',
          futurecolor: 'white',
          width: brickWidth,
          height: brickHeight
        });
    } else if (bricks.length == 0) { // ставим кирпич, не выбирая цвет
        bricks.push({
          x: clientX,
          y: clientY,
          color: 'red',
          width: brickWidth,
          height: brickHeight
        });
    } else if (bricks[bricks.length - 1].color == 'black') { // передвигаем временный кирпич и даём ему выбранный цвет
        bricks[bricks.length - 1].x = clientX;
        bricks[bricks.length - 1].y = clientY;
        bricks[bricks.length - 1].color = bricks[bricks.length - 1].futurecolor;
    } else { // продолжаем ставить кирпичи уже выбранного цвета
        bricks.push({
          x: clientX,
          y: clientY,
          color: bricks[bricks.length - 1].color,
          width: brickWidth,
          height: brickHeight
        });
    }
}
}
  </script>
</body>
</html>
